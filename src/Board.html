<section class="section">
  <div class="table-container">
    <table class="table is-bordered is-narrow">
      {#each rows as row}
      <tr>
        {#each row as field}
        <Field
          index="{field.index}"
          state="{field.state()}"
          changed="{field.hasChanged()}"
          {cellWidth}
          on:flip
        />
        {/each}
      </tr>
      {:else}
      <article>
        <h4 class="title is-4">Use</h4>
        <table class=table>
          <tr>
            <td>
              <span class="tag is-light is-medium"><strong>Board length</strong></span></td><td>to define the size of the board (length x
              length).
            </td></tr>
            <tr><td><span class="button is-primary is-active">Create Board</span></td><td>to display a randomly setup board.</td></tr>
            <tr><td>
              <span class="button is-primary is-active">Clear Board</span></td><td>to setup an empty board. You may create your own
              game by clicking on any cell to flip its state.
            </td></tr>
            <tr><td><span class="button is-info is-active">+ Generation</span></td><td>to trigger the next generation.</td></tr>
          </table>
      </article>
      {/each}
    </table>
  </div>
</section>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Field from "./Field.html"

  /*** Default Component Interface ***/
  export let rows, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("measure"))
  afterUpdate(() => dispatch("unmeasure"))
</script>

<script context="module">
  import { counter, call } from "./common/Util.html"
  import { createField } from "./Field.html"

  export const createBoard = (_dimension = 0, __measure = null) => {
    let generation
    //
    const dimension = _dimension,
      _measure = __measure,
      _fields = Array.from({ length: dimension ** 2 }, (_, idx) =>
        createField(idx)
      ),
      _row = _index => Math.floor(_index / dimension),
      _col = _index => _index % dimension,
      rows = _fields.reduce(
        (acc, field, idx) => (
          // works because idx always starts at zero!
          _col(idx) ? acc[acc.length - 1].push(field) : acc.push([field]), acc
        ),
        []
      ),
      _getField = index => _fields[index],
      //
      _doMeasure = (action, ...arg) =>
        void (_measure && _measure.start(),
        action(...arg),
        _measure && _measure.stop()),
      //
      _flip = index =>
        void (_getField(index).flip(), (generation = +generation)),
      //
      _fill = (action, _generation = "") =>
        void (action && _fields.map(call(action)), (generation = _generation)),
      //
      _next = (newStates = null, state = null, index = null) =>
        void ((newStates = _fields.reduce(
          (acc, field) => (
            (state = field.state()),
            (index = field.index),
            acc.push(
              _nextState(state, _countAlive(state, _row(index), _col(index)))
            ),
            acc
          ),
          []
        )),
        //
        _fields.map((field, idx) => field.setState(newStates[idx])),
        //
        (generation += 1)),
      //
      _nextState = (state, count) => +(count === 3 || (count === 2 && state)),
      //
      _countAlive = (state, row, col) =>
        counter(matrix, _countLife(row, col)) - state,
      //
      _countLife = (row, col) => (count, mx) =>
        (count += _validCount(mx, row, col)),
      //
      _validCount = (mx, r /*ow*/, c /*ol*/) =>
        +(([r, c] = [r + mx[0], c + mx[1]]),
        r >= 0 &&
          r < dimension &&
          c >= 0 &&
          c < dimension &&
          _getField(r * dimension + c).state()),
      //
      _count = (attr, state) =>
        counter(_fields, (acc, field) => (acc += field[attr](state)))
    //
    /*** Component Interface ***/
    return {
      //
      // static getters
      dimension,
      rows,
      size: dimension ** 2,
      //
      // dynamic getters
      generation: () => generation,
      isReady: () => generation === 0,
      countState: state => _count("hasState", state),
      countChangedState: state => _count("hasChangedState", state),
      //
      // setters
      clear: () => _doMeasure(_fill),
      create: () => _doMeasure(_fill, "setRandom", 0),
      next: () => _doMeasure(_next),
      flip: index => _doMeasure(_flip, index)
    }
  }
  //
  /*** Neighborhood ***/
  const _base = [-1, 0, 1],
    matrix = Array.from(_base, x => Array.from(_base, y => [x, y])).flat()
</script>
