<section>
	<table>
    {#each rows as row}
		<tr>
		{#each row as field}
			<td><Field index={field.index} state={field.state()}
					   changed={field.hasChanged()} on:flip/></td>
		{/each}
		</tr>
	{:else}
	<article><h3>Use
		<ul><li>{"<Board length>"} to define the size of the board (length x length).
			<li>{"<Create Board>"} to display a randomly setup board.
			<li>{"<Clear Board>"} to setup an empty board.
		You may create your own game by clicking on any cell to flip its state.
		<li>{"<+ Generation>"} to trigger the next generation.</ul></h3></article>
	{/each}
	</table>
</section>

<style>
    table {
        margin: 1em 0; border: 1px solid grey;
        border-collapse: collapse; border-spacing: 0; }
	article { margin: 1em; }
	li { margin-bottom: 1em; }
</style>

<script>
	import { createEventDispatcher, beforeUpdate, afterUpdate } from 'svelte'
	import Field from './Field.html'

    /*** Default Component Interface ***/
    export let rows

	/*** events ***/
	const dispatch = createEventDispatcher()
	beforeUpdate( () => dispatch('measure') )
	afterUpdate( () => dispatch('unmeasure') )
</script>

<script context="module">
    import { counter, call } from './common/Util.html'
    import { createField, fState } from './Field.html'

	export const createBoard = (_dimension=0, __measure=null) => {
		let generation
			//
		const
			dimension = _dimension,
			_measure = __measure,
			_fields = Array.from(
					{ length: dimension**2 },
					(_, idx) => createField(idx) ),
			_row = _index => Math.floor(_index/dimension),
			_col = _index => _index%dimension,
			rows = _fields.reduce( (acc, field) =>
				// works because _col always starts at zero!
				( _col(field.index)
					? acc[acc.length-1].push(field)
					: acc.push([field]),
				  acc ), [] ),
			//
			_getField = index => _fields[index],
			_doMeasure = (action, ...arg) => void(
				_measure && _measure.start(),
				action(...arg),
				_measure && _measure.stop() ),
			//
			_flip = index => void(
				_getField(index).flip(),
				generation = +generation ),
			//
			_fill = (action, _generation="") => void(
				_fields.map( call(action) ),
				generation = _generation ),
			//
			_next = (newStates=null, state=null, index=null) => void(
	            newStates = _fields.reduce(
					(acc, field) => (
					state = field.state(), index = field.index,
	                acc.push( _nextState(state,
							  _countAlive(state, _row(index), _col(index))) )
					, acc ), [] ),
	            //
	            _fields.map( (field, idx) =>
					field.setState(newStates[idx]) ),
	            //
				generation = ++generation ),
			//
			_nextState = (state, count) =>
			 	+( (count === 3) || (count === 2) && state ),
			//
			_countAlive = (state, row, col) =>
				counter(matrix, _countLife(row, col)) - state,
			//
			_countLife = (row, col) => (count, mx) =>
				count += _validCount(mx, row, col),
			//
			_validCount = (mx, r/*ow*/, c/*ol*/) => +(
				[r, c] = [ r+mx[0], c+mx[1] ],
				(r>=0) && (r<dimension) && (c>=0) && (c<dimension)
					   && _getField(r* dimension +c).state() ),
			//
			_count = (attr, state) =>
				counter(_fields, (acc, field) =>
					acc += field[attr](state))
		//
		/*** Component Interface ***/
		return {
			//
			// static getters
			dimension,
			rows,
			size: dimension**2,
			//
			// dynamic getters
			generation: () => generation,
			isReady: () => generation === 0,
			countState: (state) => _count("hasState", state),
			countChangedState: (state) => _count("hasChangedState", state),
			//
			// setters
			clear: () => _doMeasure(_fill, "setEmpty"),
			create: () => _doMeasure(_fill, "setRandom", 0),
			next: () => _doMeasure(_next),
			flip: (index) => _doMeasure(_flip, index)
		}
	}
	//
	/*** Neighborhood ***/
	const
		_base = [ -1, 0, 1 ],
		matrix = Array.from( _base,
					x => Array.from( _base,
						y => [x, y] ) ).flat()

</script>
