<section class="container box">
  <table class="table is-bordered is-fullwidth">
    {#each rows as row}
    <tr>
      {#each row as field}
      <Field
        index="{field.index}"
        state="{field.state()}"
        {cellWidth}
        on:flip
      />
      {/each}
    </tr>
    {:else}
    <Explanation/>
    {/each}
  </table>
</section>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Field from "./Field.html"
  import Explanation from './Explanation.html'

  /*** Default Component Interface ***/
  export let rows, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("measure"))
  afterUpdate(() => dispatch("unmeasure"))
</script>

<script context="module">
  import { counter, call } from "./common/Util.html"
  import { createField } from "./Field.html"

  export const createBoard = (_dimension = 0, __measure = null) => {
    let generation
    //
    const dimension = _dimension,
      _measure = __measure,
      _fields = Array.from({ length: dimension ** 2 }, (_, idx) =>
        createField(idx)
      ),
      _row = _index => Math.floor(_index / dimension),
      _col = _index => _index % dimension,
      rows = _fields.reduce(
        (acc, field, idx) => (
          // works because idx always starts at zero!
          _col(idx) ? acc[acc.length - 1].push(field) : acc.push([field]), acc
        ),
        []
      ),
      _getField = index => _fields[index],
      //
      _doMeasure = (action, ...arg) =>
        void (_measure && _measure.start(),
        action(...arg),
        _measure && _measure.stop()),
      //
      _flip = index =>
        void (_getField(index).flip(), (generation = +generation)),
      //
      _fill = (action, _generation = "") =>
        void (action && _fields.map(call(action)), (generation = _generation)),
      //
      _next = (newStates = null, state = null, index = null) =>
        void ((newStates = _fields.reduce(
          (acc, field) => (
            (state = field.state()),
            (index = field.index),
            acc.push(
              _nextState(state, _countAlive(state, _row(index), _col(index)))
            ),
            acc
          ),
          []
        )),
        //
        _fields.map((field, idx) => field.setState(newStates[idx])),
        //
        (generation += 1)),
      //
      _nextState = (state, count) => +(count === 3 || (count === 2 && state)),
      //
      _countAlive = (state, row, col) =>
        counter(matrix, _countLife(row, col)) - state,
      //
      _countLife = (row, col) => (count, mx) =>
        (count += _validCount(mx, row, col)),
      //
      _validCount = (mx, r /*ow*/, c /*ol*/) =>
        +(([r, c] = [r + mx[0], c + mx[1]]),
        r >= 0 &&
          r < dimension &&
          c >= 0 &&
          c < dimension &&
          _getField(r * dimension + c).state()),
      //
      _count = (attr, state) =>
        counter(_fields, (acc, field) => (acc += field[attr](state)))
    //
    /*** Component Interface ***/
    return {
      //
      // static getters
      dimension,
      rows,
      size: dimension ** 2,
      //
      // dynamic getters
      generation: () => generation,
      isReady: () => generation === 0,
      countState: state => _count("hasState", state),
      countChangedState: state => _count("hasChangedState", state),
      //
      // setters
      clear: () => _doMeasure(_fill),
      create: () => _doMeasure(_fill, "setRandom", 0),
      next: () => _doMeasure(_next),
      flip: index => _doMeasure(_flip, index)
    }
  }
  //
  /*** Neighborhood ***/
  const _base = [-1, 0, 1],
    matrix = Array.from(_base, x => Array.from(_base, y => [x, y])).flat()
</script>
