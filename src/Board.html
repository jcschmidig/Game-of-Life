<section class="container box">
  <table class="table is-bordered is-fullwidth">
    {#each rows as row}
    <tr>
      {#each row as field}
      <Field
        row="{field.row}"
        col="{field.col}"
        state="{field.state()}"
        {cellWidth}
        on:flip
      />
      {/each}
    </tr>
    {:else}
    <Explanation />
    {/each}
  </table>
</section>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Field from "./Field.html"
  import Explanation from "./Explanation.html"

  /*** Default Component Interface ***/
  export let rows, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("measure"))
  afterUpdate(() => dispatch("unmeasure"))
</script>

<script context="module">
  import {
    counter,
    filler,
    pusher,
    call,
    checkBorder
  } from "./common/Util.html"
  import { createField } from "./Field.html"

  export const createBoard = (_dimension = 0, _measure = null) => {
    let generation
    //
    const size = _dimension ** 2,
      _fields = Array.from({ length: size }, (_, idx) =>
        createField(idx, _dimension)
      ),
      rows = filler(_fields, (acc, field) =>
        // works because col always starts at zero!
        field.col ? acc[acc.length - 1].push(field) : acc.push([field])
      ),
      _getField = (row, col) => rows[row][col],
      //
      _doMeasure = (action, ...arg) =>
        void (_measure && _measure.start(),
        (generation = action(...arg)),
        _measure && _measure.stop()),
      //
      _flip = index => (_getField(index.row, index.col).flip(), +generation),
      //
      _fill = action => (action ? (_fields.map(call(action)), 0) : ""),
      //
      _next = (newStates = _getNextStates()) => (
        _fields.map((field, idx) => field.setState(newStates[idx])),
        generation + 1
      ),
      //
      _getNextStates = () =>
        pusher(_fields, field =>
          _nextState(field.state(), countAlive(field.row, field.col))
        ),
      //
      _nextState = (state, count) => +(count === 3 || count - state === 3),
      //
      countAlive = (row, col) =>
        counter(matrix, (count, mx) => count + _stateCount(mx, row, col)),
      //
      _stateCount = (mx, row, col) =>
        checkBorder((row += mx[0]), -1, _dimension) &&
        checkBorder((col += mx[1]), -1, _dimension) &&
        _getField(row, col).state(),
      //
      _count = (attr, state) =>
        counter(_fields, (acc, field) => acc + field[attr](state))
    //
    /*** Component Interface ***/
    return {
      //
      // static getters
      size,
      rows,
      //
      // dynamic getters
      generation: () => generation,
      isReady: () => generation === 0,
      countState: state => _count("hasState", state),
      countChangedState: state => _count("hasChangedState", state),
      //
      // setters
      clear: () => _doMeasure(_fill),
      create: () => _doMeasure(_fill, "setRandom"),
      next: () => _doMeasure(_next),
      flip: index => _doMeasure(_flip, index)
    }
  }
  //
  /*** Neighborhood ***/
  const _base = [-1, 0, 1],
    matrix = Array.from(_base, x => Array.from(_base, y => [x, y])).flat()
</script>
