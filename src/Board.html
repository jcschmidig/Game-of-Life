<script context="module">
  import * as u from "./common/Util.html"
  import * as f from "./Field.html"

  /*** Neighborhood ***/
  const _mx = [-1, 0, 1],
    Neighborhood = Array.from(_mx, x => Array.from(_mx, y => [x, y])).flat()

  const createStat = size => {
    let birth = 0,
      death = 0,
      alive = 0
    //
    const calc = (newState, oldState) => {
      if (newState === oldState) return
      //
      birth += +newState
      death += +oldState
      alive += +newState - oldState
    }
    //
    return {
      birth: () => birth,
      death: () => death,
      alive: () => alive,
      dead: () => size - alive,
      reset: () => void (birth = death = 0),
      calc
    }
  }

  export const createBoard = (dimension = 0) => {
    const size = dimension ** 2,
      stat = createStat(size),
      _index = (row, col) => row * dimension + col,
      _coord = idx => ({ row: ~~(idx / dimension), col: idx % dimension })
    let fields,
      generation = 0
    //
    const _field = (row, col) => fields[_index(row, col)],
      _set = ({ row, col }, field) => void (fields[_index(row, col)] = field),
      //
      _checkAlive = (ngb, { row, col }) =>
        u.checkLimit((row += ngb[0]), dimension) &&
        u.checkLimit((col += ngb[1]), dimension) &&
        _field(row, col).state,
      //
      _newField = (field, action, arg) => {
        const newField = action(field, arg)
        stat.calc(newField.state, field.state || false)
        return newField
      },
      //
      clear = () => {
        fields = u.fillArray(size)(f.create, _coord)
      },
      //
      create = () => {
        fields = u.fillArray(size)(_newField, _coord, f.random)
      },
      //
      next = () => {
        generation += 1
        stat.reset()
        fields = fields.map(field =>
          _newField(
            field,
            f.next,
            u.propCounter(Neighborhood)(_checkAlive, field)
          )
        )
      },
      //
      flip = field => _set(field, _newField(field, f.flip))
    //
    /*** Component Interface ***/
    return {
      // static getters ---------------------
      length: dimension,
      stat,
      // dynamic getters --------------------
      generation: () => generation,
      fields: () => fields,
      // setters ----------------------------
      clear,
      create,
      next,
      flip
    }
  }
</script>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Explanation from "./Explanation.html"

  /*** Default Component Interface ***/
  export let fields, screenWidth, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("startMeasure"))
  afterUpdate(() => dispatch("endMeasure"))
</script>

<section class="container box">
  {#if !fields}
  <Explanation />
  {/if}{#if fields && !cellWidth}
  <h2 class="title is-2 has-text-centered">Screen too small!</h2>
  {/if}{#if fields && cellWidth}
  <svg width="{screenWidth}" height="{screenWidth}">
    {#each fields as field} <rect height="{cellWidth}" width="{cellWidth}"
    class:alive="{field.state}" x="{cellWidth * field.col + 1}" y="{cellWidth *
    field.row + 1}" on:click={() => dispatch("flip", field)} /> {/each}
  </svg>
  {/if}
</section>

<style>
  section {
    padding-left: 0;
    padding-right: 0;
  }
  svg {
    display: block;
    margin: auto;
    fill: #ddd;
  }
  rect.alive {
    fill: #00d1b2;
  }
</style>
