<section class="container box">
  {#if fields}
  <svg width="{screenWidth}" height="{screenWidth}">
    {#each fields as {row, col, state}} <rect height={cellWidth}
    width={cellWidth} class:alive={state()} x={cellWidth * col + 1} y={cellWidth
    * row + 1} on:click={() => dispatch("flip", [row, col])} /> {/each}
  </svg>
  {:else}
  <Explanation />
  {/if}
</section>

<style>
  section {
    padding-left: 0;
    padding-right: 0;
  }
  svg {
    display: block;
    margin: auto;
    fill: #ddd;
  }
  rect.alive {
    fill: #00d1b2;
  }
</style>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Explanation from "./Explanation.html"

  /*** Default Component Interface ***/
  export let fields, screenWidth, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("measure"))
  afterUpdate(() => dispatch("unmeasure"))
</script>

<script context="module">
  import {
    propCounter,
    objCounter,
    pusher,
    mapper,
    fillArray,
    call,
    checkBorder
  } from "./common/Util.html"
  import { createField } from "./Field.html"

  export const createBoard = (dimension = 0, measure = null) => {
    let generation = 0
    //
    const size = dimension ** 2,
      _fields = fillArray(size, createField, dimension),
      fields = _fields.map(f => f.stat),
      _index = (row, col) => row * dimension + col,
      _field = (row, col, idx = _index(row, col)) => _fields[idx],
      _stat = (row, col, idx = _index(row, col)) => fields[idx],
      //
      _doMeasure = (action, ...arg) =>
        void (measure && measure.start(),
        (generation = action(...arg)),
        measure && measure.stop()),
      //
      _flip = idx => (_field(...idx).flip(), generation),
      //
      _fill = action => (_fields.map(call(action)), 0),
      //
      _next = () => (
        mapper(_fields)("setState", _getNextStates()), generation + 1
      ),
      //
      _getNextStates = () =>
        pusher(_fields)(field =>
          field.nextState(propCounter(Neighborhood)(_checkAlive, field.stat))
        ),
      //
      _checkAlive = (ngb, { row, col }) =>
        _checkBorder((row += ngb[0])) &&
        _checkBorder((col += ngb[1])) &&
        _stat(row, col).state(),
      //
      _checkBorder = value => checkBorder(value, dimension),
      //
      _fieldCount = (prop, state) => objCounter(_fields)(prop, state),
      //
      /*** Neighborhood ***/
      _base = [-1, 0, 1],
      Neighborhood = Array.from(_base, x =>
        Array.from(_base, y => [x, y])
      ).flat()
    //
    /*** Component Interface ***/
    return {
      //
      // static getters
      size,
      fields,
      //
      // dynamic getters
      generation: () => generation,
      countState: state => _fieldCount("hasState", state),
      countChangedState: state => _fieldCount("hasChangedState", state),
      //
      // setters
      clear: () => _doMeasure(_fill),
      create: () => _doMeasure(_fill, "setRandom"),
      next: () => _doMeasure(_next),
      flip: index => _doMeasure(_flip, index)
    }
  }
</script>
