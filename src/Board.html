<section class="container box">
  {#if fields} {#if cellWidth}
  <svg width="{screenWidth}" height="{screenWidth}">
    {#each fields as {stat}} <rect height={cellWidth} width={cellWidth}
    class:alive={stat.state()} x={cellWidth * stat.col + 1} y={cellWidth *
    stat.row + 1} on:click={() => dispatch("flip", [stat.row, stat.col])} />
    {/each}
  </svg>
  {:else}
  <h2 class="title is-2 has-text-centered">Screen too small!</h2>
  {/if} {:else}
  <Explanation />
  {/if}
</section>

<style>
  section {
    padding-left: 0;
    padding-right: 0;
  }
  svg {
    display: block;
    margin: auto;
    fill: #ddd;
  }
  rect.alive {
    fill: #00d1b2;
  }
</style>

<script>
  import { createEventDispatcher, beforeUpdate, afterUpdate } from "svelte"
  import Explanation from "./Explanation.html"

  /*** Default Component Interface ***/
  export let fields, screenWidth, cellWidth

  /*** events ***/
  const dispatch = createEventDispatcher()
  beforeUpdate(() => dispatch("measure"))
  afterUpdate(() => dispatch("unmeasure"))
</script>

<script context="module">
  import {
    propCounter,
    objCounter,
    pusher,
    mapper,
    fillArray,
    call,
    checkBorder
  } from "./common/Util.html"
  import { createField } from "./Field.html"

  export const createBoard = (dimension = 0, measure = null) => {
    let generation = 0
    //
    const size = dimension ** 2,
      fields = fillArray(size, createField, dimension),
      _index = obj => (row, col) => obj[row * dimension + col],
      _field = (row, col) => _index(fields)(row, col),
      _state = (row, col) => _field(row, col).stat.state(),
      //
      _doMeasure = (action, ...arg) =>
        void (measure && measure.start(),
        (generation = action(...arg)),
        measure && measure.stop()),
      //
      _flip = idx => (_field(...idx).flip(), generation),
      //
      _fill = action => (fields.map(call(action)), 0),
      //
      _next = () => (
        mapper(fields)("setState", _getNextStates()), generation + 1
      ),
      //
      _getNextStates = () =>
        pusher(fields)(field =>
          field.nextState(propCounter(Neighborhood)(_checkAlive, field.stat))
        ),
      //
      _checkAlive = (ngb, { row, col }) =>
        _checkBorder((row += ngb[0])) &&
        _checkBorder((col += ngb[1])) &&
        _state(row, col),
      //
      _checkBorder = value => checkBorder(value, dimension),
      //
      _fieldCount = (prop, state) => objCounter(fields)(prop, state),
      //
      /*** Neighborhood ***/
      _matrix = [-1, 0, 1],
      Neighborhood = Array.from(_matrix, x =>
        Array.from(_matrix, y => [x, y])
      ).flat()
    //
    /*** Component Interface ***/
    return {
      //
      // static getters
      size,
      fields,
      //
      // dynamic getters
      generation: () => generation,
      countState: state => _fieldCount("hasState", state),
      countChangedState: state => _fieldCount("hasChangedState", state),
      //
      // setters
      clear: () => _doMeasure(_fill),
      create: () => _doMeasure(_fill, "setRandom"),
      next: () => _doMeasure(_next),
      flip: index => _doMeasure(_flip, index)
    }
  }
</script>
