{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/Game.html",
    "../src/Board.html",
    "../src/Start.html",
    "../src/common/Measure.html",
    "../src/Field.html",
    "../src/common/Button.html"
  ],
  "sourcesContent": [
    "<section>\n\t<article class=show>\n\t\t<Measure style={__total} title=\"Total\" diff={blank(_birth + _death)}/>\n\t\t<hr/>\n\t\t<Measure style={__birth} title=\"Birth\" diff={blank(_birth)}/>\n\t\t<Measure style={__death} title=\"Death\" diff={blank(_death)}/>\n\t</article>\n\t<article id=generation>\n\t\t<Button id=\"next\" name={_showName} width=\"10em\" height=\"5em\"\n\t\t\t\tstyle=\"cursor: copy;\"\n\t\t\t\tdisabled={!_nextEnabled} on:click/>\n\t</article>\n\t<article class=show>\n\t\t<Measure style={__total} title=\"Total\" diff={blank(_alive + _dead)}/>\n\t\t<hr/>\n\t\t<Measure style={__alive} title=\"Alive\" diff={blank(_alive)}/>\n\t\t<Measure style={__dead} title=\"Dead\" diff={blank(_dead)}/>\n\t</article>\n    <article class=show>\n\t\t<div id=time>Time (ms)</div>\n\t\t<hr/>\n\t\t<Measure title={calc.title} diff={_timeCalc}/>\n\t\t<Measure title={showTitle} diff={showDiff}/>\n\t</article>\n</section>\n\n<style>\n    section { min-height: 5.5em; margin-top: 1.5em; }\n    article { float: left; width: 8em; margin-right: .8em; }\n\tarticle#generation { width: auto; }\n    .show { border: 1px solid darkgrey; padding: .2em; }\n    .right { float: right; }\n    div#time { font-style: italic; }\n</style>\n\n<script>\n    import { counter, blank } from './common/Util.html'\n    import { fState } from './Field.html'\n\timport Button from './common/Button.html'\n\timport Measure from './common/Measure.html'\n\n    /*** Default Component Interface ***/\n    export let status, calc, showTitle, showDiff\n\n\t/*** measure styles ***/\n\tconst\n\t\t__total = \"font-weight: 900;\",\n\t\t__birth = \"color: blue;\",\n\t\t__death = \"color: black;\",\n\t\t__alive = \"background-color: aqua;\",\n\t\t__dead = \"background-color: lightgrey;\"\n\n    /*** Observables ***/\n    let _alive, _dead, _birth, _death,\n        _timeCalc, _showgen=\"-\", _nextEnabled\n    $: {\n        status && (\n            _alive = status.countState(fState.alive),\n            _dead = status.size - _alive,\n            _birth = status.countChangedState(fState.alive),\n            _death = status.countChangedState(fState.dead),\n            _timeCalc = calc.diff(),\n            _showgen = (status.generation === \"\") ? \"-\" : status.generation,\n\t\t\t_showName = \"+ Generation (\" + _showgen + \")\",\n            _nextEnabled = status.isReady || _birth || _death )\n        }\n\t$: _showName = \"+ Generation (\" + _showgen + \")\"\n</script>\n",
    "<section>\n\t<table>\n    {#each rows as row}\n\t\t<tr>\n\t\t{#each row as field}\n\t\t\t<td><Field index={field.index} state={field.state()}\n\t\t\t\t\t   changed={field.hasChanged()} on:flip/></td>\n\t\t{/each}\n\t\t</tr>\n\t{:else}\n\t<article><h3>Use\n\t\t<ul><li>{\"<Board length>\"} to define the size of the board (length x length).\n\t\t\t<li>{\"<Create Board>\"} to display a randomly setup board.\n\t\t\t<li>{\"<Clear Board>\"} to setup an empty board.\n\t\tYou may create your own game by clicking on any cell to flip its state.\n\t\t<li>{\"<+ Generation>\"} to trigger the next generation.</ul></h3></article>\n\t{/each}\n\t</table>\n</section>\n\n<style>\n    table {\n        margin: 1em 0; border: 1px solid grey;\n        border-collapse: collapse; border-spacing: 0; }\n\tarticle { margin: 1em; }\n\tli { margin-bottom: 1em; }\n</style>\n\n<script>\n\timport { createEventDispatcher, beforeUpdate, afterUpdate } from 'svelte'\n\timport Field from './Field.html'\n\n    /*** Default Component Interface ***/\n    export let rows\n\n\t/*** events ***/\n\tconst dispatch = createEventDispatcher()\n\tbeforeUpdate( () => dispatch('measure') )\n\tafterUpdate( () => dispatch('unmeasure') )\n</script>\n\n<script context=\"module\">\n    import { counter, call } from './common/Util.html'\n    import { createField, fState } from './Field.html'\n\n\texport const createBoard = (_dimension=0, __measure=null) => {\n\t\tlet generation\n\t\t\t//\n\t\tconst\n\t\t\tdimension = _dimension,\n\t\t\t_measure = __measure,\n\t\t\t_fields = Array.from(\n\t\t\t\t\t{ length: dimension**2 },\n\t\t\t\t\t(_, idx) => createField(idx) ),\n\t\t\t_row = _index => Math.floor(_index/dimension),\n\t\t\t_col = _index => _index%dimension,\n\t\t\trows = _fields.reduce( (acc, field) =>\n\t\t\t\t// works because _col always starts at zero!\n\t\t\t\t( _col(field.index)\n\t\t\t\t\t? acc[acc.length-1].push(field)\n\t\t\t\t\t: acc.push([field]),\n\t\t\t\t  acc ), [] ),\n\t\t\t//\n\t\t\t_getField = index => _fields[index],\n\t\t\t_doMeasure = (action, ...arg) => void(\n\t\t\t\t_measure && _measure.start(),\n\t\t\t\taction(...arg),\n\t\t\t\t_measure && _measure.stop() ),\n\t\t\t//\n\t\t\t_flip = index => void(\n\t\t\t\t_getField(index).flip(),\n\t\t\t\tgeneration = +generation ),\n\t\t\t//\n\t\t\t_fill = (action, _generation=\"\") => void(\n\t\t\t\t_fields.map( call(action) ),\n\t\t\t\tgeneration = _generation ),\n\t\t\t//\n\t\t\t_next = (newStates=null, state=null, index=null) => void(\n\t            newStates = _fields.reduce(\n\t\t\t\t\t(acc, field) => (\n\t\t\t\t\tstate = field.state(), index = field.index,\n\t                acc.push( _nextState(state,\n\t\t\t\t\t\t\t  _countAlive(state, _row(index), _col(index))) )\n\t\t\t\t\t, acc ), [] ),\n\t            //\n\t            _fields.map( (field, idx) =>\n\t\t\t\t\tfield.setState(newStates[idx]) ),\n\t            //\n\t\t\t\tgeneration = ++generation ),\n\t\t\t//\n\t\t\t_nextState = (state, count) =>\n\t\t\t \t+( (count === 3) || (count === 2) && state ),\n\t\t\t//\n\t\t\t_countAlive = (state, row, col) =>\n\t\t\t\tcounter(matrix, _countLife(row, col)) - state,\n\t\t\t//\n\t\t\t_countLife = (row, col) => (count, mx) =>\n\t\t\t\tcount += _validCount(mx, row, col),\n\t\t\t//\n\t\t\t_validCount = (mx, r/*ow*/, c/*ol*/) => +(\n\t\t\t\t[r, c] = [ r+mx[0], c+mx[1] ],\n\t\t\t\t(r>=0) && (r<dimension) && (c>=0) && (c<dimension)\n\t\t\t\t\t   && _getField(r* dimension +c).state() ),\n\t\t\t//\n\t\t\t_count = (attr, state) =>\n\t\t\t\tcounter(_fields, (acc, field) =>\n\t\t\t\t\tacc += field[attr](state))\n\t\t//\n\t\t/*** Component Interface ***/\n\t\treturn {\n\t\t\t//\n\t\t\t// static getters\n\t\t\tdimension,\n\t\t\trows,\n\t\t\tsize: dimension**2,\n\t\t\t//\n\t\t\t// dynamic getters\n\t\t\tgeneration: () => generation,\n\t\t\tisReady: () => generation === 0,\n\t\t\tcountState: (state) => _count(\"hasState\", state),\n\t\t\tcountChangedState: (state) => _count(\"hasChangedState\", state),\n\t\t\t//\n\t\t\t// setters\n\t\t\tclear: () => _doMeasure(_fill, \"setEmpty\"),\n\t\t\tcreate: () => _doMeasure(_fill, \"setRandom\", 0),\n\t\t\tnext: () => _doMeasure(_next),\n\t\t\tflip: (index) => _doMeasure(_flip, index)\n\t\t}\n\t}\n\t//\n\t/*** Neighborhood ***/\n\tconst\n\t\t_base = [ -1, 0, 1 ],\n\t\tmatrix = Array.from( _base,\n\t\t\t\t\tx => Array.from( _base,\n\t\t\t\t\t\ty => [x, y] ) ).flat()\n\n</script>\n",
    "<section >\n\t<label for=\"dim\">Board length</label>\n\t<input id=\"dim\" title=\"between {dimMin} and {dimMax}!\"\n\t\t   type=\"number\" min={dimMin} max={dimMax} bind:value={dimension}\n\t\t   on:keyup={keyEnter} on:change={checkDimension}/>\n\t<Button name=\"Create Board\" width={buttonWidth} style=\"margin-right: .7em;\"\n\t\t\ton:click={createBoard}/>\n\t<Button name=\"Clear Board\" width={buttonWidth}\n\t\t\ton:click={clearBoard}/>\n</section>\n\n<style>\n\tsection { height: 4em; }\n\tinput { width: 6em; margin-right: 3.1em; text-align: right; }\n</style>\n\n<script>\n\timport { createEventDispatcher, onMount } from 'svelte'\n\timport { setFocus, checkMinMax } from './common/Util.html'\n\timport Button from './common/Button.html'\n\n\t/*** Default Component Interface ***/\n\texport let defDimension = 12, dimMin = 1, dimMax = 1000\n\tlet dimension = defDimension\n\tconst buttonWidth = \"13.8em\"\n\n\t/*** Events ***/\n\tconst\n\t\tkeyEnter = (ev, key=ev.which) => key === 13 && createBoard(),\n\t\tcheckDimension = (ev, dim = ev.target.value) =>\n\t\t\tvoid( dimension = checkMinMax(dim, dimMin, dimMax) ),\n\t\t//\n\t\tdispatch = createEventDispatcher(),\n\t\tevt = (action, focus) => ( setFocus(focus), dispatch(action, dimension) ),\n\t\tcreateBoard = () => evt(\"create\", \"next\"),\n\t\tclearBoard = () => evt(\"clear\", \"dim\")\n\t//\n\t// set the focus to the input element within the start of the page\n\tonMount( () => { setFocus('dim') } )\n</script>\n",
    "<div {style}><span>{title}:</span>\n             <span class=right>{blank(diff)}</span></div>\n\n<style>\n    .right { float: right; }\n</style>\n\n<script>\n    import { blank } from './Util.html'\n    /*** Default Component Interface ***/\n    export let title, diff, style = \"\", mClass\n</script>\n\n<script context=\"module\">\n    export const createMeasure = _title => {\n        let _m1, _m2\n        //\n        const\n            title = _title,\n            _now = () => window.performance.now(),\n            start = () => void ( _m1 = _now() ),\n            stop = () => void ( _m2 = _now() ),\n            diff = () => Math.floor( (_m2 - _m1) * 1000 )/1000\n        //\n        /*** Component Interface ***/\n        return {\n            // static getter\n            title,\n            // dynamic getter\n            diff,\n            // setters\n            start,\n            stop: () => ( stop(), diff() )\n        }\n    }\n</script>\n",
    "<button class=\"{_colorState} {_colorCycle}\" on:click={flip}/>\n\n<style>\n    button {\n        width: 30px; height: 30px; border-width: 2px;\n        cursor: crosshair; margin: 2px; padding: 1px; }\n    .dead { background-color: lightgrey; }\n    .alive { background-color: aqua; }\n    .unchanged { border-color: white; }\n    .changed-dead { border-color: black; }\n    .changed-alive { border-color: blue; }\n</style>\n\n<script>\n    import { createEventDispatcher } from 'svelte'\n\n    /***  Default Component Interface ***/\n    export let index, state, changed\n\n    /*** Observables ***/\n    // background color based on state\n    $: _colorState = state ? \"alive\" : \"dead\"\n    // border color based on change\n    $: _colorCycle = changed ? \"changed-\"+_colorState : \"unchanged\"\n\n    /*** Events ***/\n    const\n        dispatch = createEventDispatcher(),\n        flip = () => dispatch( \"flip\", index )\n</script>\n\n<script context=\"module\">\n    /*** field states ***/\n    export const fState = { alive: 1, dead: 0 }\n    //\n    export const createField = (_pos=0) => {\n        const index = _pos\n        let _state = fState.dead, _prevState = null\n        //\n        const\n            hasChanged = () => _state^_prevState,\n            hasState = state => _state === state,\n            //\n            _set = (state=fState.dead, prevState=state) =>\n                void( _state = state, _prevState = prevState ),\n            _changeTo = state => _set(state, _state)\n        //\n        // Component Interface\n        return {\n            //\n            // static getters\n            index,\n            //\n            // dynamic getters\n            state: () => _state,\n            hasState,\n            hasChanged,\n            hasChangedState: (state) => hasState(state) && hasChanged(),\n            //\n            // setters\n            setState: state => _changeTo(state),\n            setEmpty: () => _set(),\n            setRandom: () => _set(Math.round(Math.random())),\n            flip: () => _changeTo(+!_state)\n        }\n    }\n</script>\n",
    "<button id={id} style={_buttonStyle} {disabled} on:click>{name}</button>\n\n<style>\n\tbutton:focus { border-color: green; border-width: 2px; }\n    button[disabled] {\n        border: none;\n        background-color: lightgray;\n        cursor: not-allowed !important; }\n</style>\n\n<script>\n    /*** Default Component Interface ***/\n    export let\n        id=\"\", name=\"Submit\",\n        width=\"\", height=\"\",\n        style=\"\", disabled=\"\"\n\n    /*** Observables ***/\n    $: _buttonStyle = (width ? \"width: \"+width+\"; \" : \"\") +\n                      (height ? \"height: \"+height+\"; \" : \"\") +\n                       style\n</script>\n"
  ],
  "names": [],
  "mappings": "AA2BI,OAAO,cAAC,CAAC,AAAC,UAAU,CAAE,KAAK,CAAE,UAAU,CAAE,KAAK,AAAE,CAAC,AACjD,OAAO,cAAC,CAAC,AAAC,KAAK,CAAE,IAAI,CAAE,KAAK,CAAE,GAAG,CAAE,YAAY,CAAE,IAAI,AAAE,CAAC,AAC3D,OAAO,WAAW,cAAC,CAAC,AAAC,KAAK,CAAE,IAAI,AAAE,CAAC,AAChC,KAAK,cAAC,CAAC,AAAC,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAE,OAAO,CAAE,IAAI,AAAE,CAAC,AAEpD,GAAG,KAAK,cAAC,CAAC,AAAC,UAAU,CAAE,MAAM,AAAE,CAAC;ACXhC,KAAK,eAAC,CAAC,AACH,MAAM,CAAE,GAAG,CAAC,CAAC,CAAE,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACrC,eAAe,CAAE,QAAQ,CAAE,cAAc,CAAE,CAAC,AAAE,CAAC,AACtD,OAAO,eAAC,CAAC,AAAC,MAAM,CAAE,GAAG,AAAE,CAAC,AACxB,EAAE,eAAC,CAAC,AAAC,aAAa,CAAE,GAAG,AAAE,CAAC;ACb1B,OAAO,cAAC,CAAC,AAAC,MAAM,CAAE,GAAG,AAAE,CAAC,AACxB,KAAK,cAAC,CAAC,AAAC,KAAK,CAAE,GAAG,CAAE,YAAY,CAAE,KAAK,CAAE,UAAU,CAAE,KAAK,AAAE,CAAC;ACT1D,MAAM,cAAC,CAAC,AAAC,KAAK,CAAE,KAAK,AAAE,CAAC;ACDxB,MAAM,eAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CAAE,MAAM,CAAE,IAAI,CAAE,YAAY,CAAE,GAAG,CAC5C,MAAM,CAAE,SAAS,CAAE,MAAM,CAAE,GAAG,CAAE,OAAO,CAAE,GAAG,AAAE,CAAC,AACnD,KAAK,eAAC,CAAC,AAAC,gBAAgB,CAAE,SAAS,AAAE,CAAC,AACtC,MAAM,eAAC,CAAC,AAAC,gBAAgB,CAAE,IAAI,AAAE,CAAC,AAClC,UAAU,eAAC,CAAC,AAAC,YAAY,CAAE,KAAK,AAAE,CAAC,AACnC,aAAa,eAAC,CAAC,AAAC,YAAY,CAAE,KAAK,AAAE,CAAC,AACtC,cAAc,eAAC,CAAC,AAAC,YAAY,CAAE,IAAI,AAAE,CAAC;ACPzC,oBAAM,MAAM,AAAC,CAAC,AAAC,YAAY,CAAE,KAAK,CAAE,YAAY,CAAE,GAAG,AAAE,CAAC,AACrD,MAAM,CAAC,QAAQ,CAAC,cAAC,CAAC,AACd,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,SAAS,CAC3B,MAAM,CAAE,WAAW,CAAC,UAAU,AAAE,CAAC"
}